# 비트마스킹
### 음수의 이진수 표현
양수 n을 이진수 변환 및 비트 반전 후 +1

5 => 0101 => 1010 => 1011 => -5

### 비트마스킹을 활용한 케이스 관리
N가지의 항목을 활용하여 경우의 수를 파악

a는 기존 케이스 b는 n(0 ~ , 좌->우)번째 항목에 대한 추가/제거/조회/토글
* 추가
``` java
a |= (1<<b);
   
//a=5, b=3 0101(5) | 1000(8) => 1101(13)
```
* 제거
``` java
a &= ~(1<<b);

//a=7, b=2 0111(7) & 1011(~4) => 0011(3)
```
* 조회
```java
(a & (1<<b)) > 0;

//true일 경우 포함되어있음
//a=5, b=3 0101(5) & 1000(8) => 0000(0) false(미포함)
//a=7, b=2 0111(7) & 0100(4) => 0100(4) true(포함, 2번째 항목이 포함)
```
* 토글
```java
a ^= (1<<b);

//a=7, b=2 0111(7) ^ 0100(4) => 0011(3) 2번째 항목만 토글
```
* 전체 추가
```java
a = -1;

//-1의 2진수는 1111111111
```
* 전체 제거
```java
a = 0;
```

### 브루트포스
```java
for(int i = 0; i < (1>>N); i++){ //N가지 항목에 대한 완전 탐색
  for(int j = 0; j < N; j++){ //N가지 항목 확인
    if(i & (1<<j)) > 0{
      //포함된 경우 처리
    }
    else{
      //미포함된 경우 처리
    }
  }
}
```

### Integer 클래스
```java
String s = Integer.toBinaryString(n); //n에 대한 이진수 표현
int cnt = Integer.bitCount(n); //n을 이진수로 변환했을 때 1의 개수
```

### BitSet 클래스
* 각 비트를 저장하기 위한 배열
* 크기는 고정
* 비트 연산 지원 및 비트 단위로 데이터 조작
* ```java
  bitSet.set(int index); //지정된 인덱스의 비트를 1로 설정
  bitSet.clear(int index); //지정된 인덱스의 비트를 0으로 설정
  bitSet.get(int index); //지정된 인덱스의 비트 값을 반환
  bitSet.flip(int index); //지정된 인덱스의 비트를 토글
  bitSet.and(BitSet set); //다른 BitSet과의 AND 연산을 수행
  bitSet.or(BitSet set); //다른 BitSet과의 OR 연산을 수행
  bitSet.xor(BitSet set); //다른 BitSet과의 XOR 연산을 수행
  ```

### 그 외
```java
n &= n-1; //n의 가장 오른쪽에 있는 1비트 제거
n & (-n); //n의 가장 오른쪽에 있는 1비트만 유지
n & (-1); //n의 모든 비트 토글
```
